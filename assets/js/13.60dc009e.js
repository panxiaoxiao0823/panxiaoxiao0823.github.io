(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{363:function(e,a,r){"use strict";r.r(a);var n=r(23),t=Object(n.a)({},(function(){var e=this,a=e.$createElement,r=e._self._c||a;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("h1",{attrs:{id:"接口"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#接口"}},[e._v("#")]),e._v(" 接口")]),e._v(" "),r("ClientOnly",[r("click")],1),e._v(" "),r("h2",{attrs:{id:"简单的接口示例"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#简单的接口示例"}},[e._v("#")]),e._v(" 简单的接口示例")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v('interface LabelledValue { // 接口一般首字母大写\n  label: string;\n}\n\nfunction printLabel(labelledObj: LabelledValue) {\n  console.log(labelledObj.label);\n}\n\nlet myObj = {size: 10, label: "Size 10 Object"};\nprintLabel(myObj);\n')])])]),r("p",[e._v("LabelledValue接口就好比一个名字，用来描述上面例子里的要求。 它代表了有一个 label属性且类型为string的对象。")]),e._v(" "),r("h2",{attrs:{id:"可选属性"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#可选属性"}},[e._v("#")]),e._v(" 可选属性")]),e._v(" "),r("p",[e._v("带有可选属性的接口与普通的接口定义差不多，只是在可选属性名字定义的后面加一个?符号。")]),e._v(" "),r("p",[e._v("可选属性的好处之一是可以对可能存在的属性进行预定义，好处之二是可以捕获引用了不存在的属性时的错误。 比如，我们故意将 createSquare里的color属性名拼错，就会得到一个错误提示：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("interface SquareConfig {\n  color?: string;\n  width?: number;\n}\n\nfunction createSquare(config: SquareConfig): { color: string; area: number } {  //这里的 : { color: string; area: number } 是函数createSquare的返回值静态类型\n  let newSquare = {color: \"white\", area: 100};\n  if (config.clor) {\n    // Error: Property 'clor' does not exist on type 'SquareConfig'\n    newSquare.color = config.clor;\n  }\n  if (config.width) {\n    newSquare.area = config.width * config.width;\n  }\n  return newSquare;\n}\n\nlet mySquare = createSquare({color: \"black\"});\n")])])]),r("h2",{attrs:{id:"只读属性"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#只读属性"}},[e._v("#")]),e._v(" 只读属性")]),e._v(" "),r("p",[e._v("一些对象属性只能在对象刚刚创建的时候修改其值。 你可以在属性名前用 readonly来指定只读属性:")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("interface Point {\n    readonly x: number;\n    readonly y: number;\n}\n")])])]),r("p",[e._v("你可以通过赋值一个对象字面量来构造一个Point。 赋值后， x和y再也不能被改变了。")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("let p1: Point = { x: 10, y: 20 };\np1.x = 5; // error!\n")])])]),r("p",[e._v("TypeScript具有"),r("code",[e._v("ReadonlyArray<T>")]),e._v("类型，它与"),r("code",[e._v("Array<T>")]),e._v("相似，只是把所有可变方法去掉了，因此可以确保数组创建后再也不能被修改：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("let a: number[] = [1, 2, 3, 4];\nlet ro: ReadonlyArray<number> = a;\nro[0] = 12; // error!\nro.push(5); // error!\nro.length = 100; // error!\na = ro; // error!  The type 'readonly number[]' is 'readonly' and cannot be assigned to the mutable type 'number[]'.\n")])])]),r("p",[e._v("上面代码的最后一行，可以看到就算把整个ReadonlyArray赋值到一个普通数组也是不可以的。 但是你可以用类型断言重写：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("a = ro as number[];\n\n//因为a的类型是number[],所以如果把ro赋值给一个新的没有类型的值是可以的。\nlet c = ro; //true\n")])])]),r("h2",{attrs:{id:"额外的属性检查"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#额外的属性检查"}},[e._v("#")]),e._v(" 额外的属性检查")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("interface SquareConfig {\n    color?: string;\n    width?: number;\n}\n\nfunction createSquare(config: SquareConfig): { color: string; area: number } {\n    // ...\n}\n\nlet mySquare = createSquare({ colour: \"red\", width: 100 }); // error: 'colour' not expected in type 'SquareConfig'\n")])])]),r("p",[e._v("上面代码会报错，原因是 对象字面量会被特殊对待而且会经过 额外属性检查，当将它们赋值给变量或作为参数传递的时候。 如果一个对象字面量存在任何“目标类型”不包含的属性时，你会得到一个错误。")]),e._v(" "),r("p",[e._v("绕开这些检查非常简单：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v('//方法一：类型断言\nlet mySquare = createSquare({ width: 100, opacity: 0.5 } as SquareConfig);\n\n//方法二：添加一个字符串索引签名\ninterface SquareConfig {\n    color?: string;\n    width?: number;\n    [propName: string]: any;\n}\n\n//方法三：将这个对象赋值给一个另一个变量\nlet squareOptions = { colour: "red", width: 100 };\nlet mySquare = createSquare(squareOptions);\n')])])]),r("p",[e._v("上面代码的"),r("code",[e._v("[propName:string]:any")]),e._v("即表示任意属性，需要注意的是，一旦定义了任意属性，那么确定属性和可选属性的类型都必须是它的类型的子集：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("interface SquareConfig {\n    color: string;\n    width?: number;\n    [propName: string]: string;\n}\n\nlet a : SquareConfig = {\n    color:'red',\n    width:20 //error 属性“width”与索引签名不兼容。 不能将类型“number”分配给类型“string”。\n}\n")])])]),r("p",[e._v("一个接口中只能定义一个任意属性。如果接口中有多个类型的属性，则可以在任意属性中使用联合类型")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("interface SquareConfig {\n    color: string;\n    width?: number;\n    [propName: string]: string | number;\n}\n\nlet a : SquareConfig = {\n    color:'red',\n    width:20\n}\n")])])]),r("h2",{attrs:{id:"函数类型"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#函数类型"}},[e._v("#")]),e._v(" 函数类型")]),e._v(" "),r("p",[e._v("为了使用接口表示函数类型，我们需要给接口定义一个调用签名。 它就像是一个只有参数列表和返回值类型的函数定义。参数列表里的每个参数都需要名字和类型。")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("interface fn {\n    (a: string, b: number): number //(a: string, b: number)是参数类型  // : number是函数返回值类型\n}\n\nlet c : fn;\nc = function (e, f) { //这里的参数可以不用和fn函数接口的参数一致，即不用一定是a/b\n    return 2;\n}\nc('1', 3)\n")])])]),r("h2",{attrs:{id:"可索引的类型"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#可索引的类型"}},[e._v("#")]),e._v(" 可索引的类型")]),e._v(" "),r("p",[e._v("与使用接口描述函数类型差不多，我们也可以描述那些能够“通过索引得到”的类型，比如"),r("code",[e._v("a[10]")]),e._v("或"),r("code",[e._v('ageMap["daniel"]')]),e._v("。 可索引类型具有一个 索引签名，它描述了对象索引的类型，还有相应的索引返回值类型。")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v('interface StringArray {\n  [index: number]: string;\n}\n\nlet myArray: StringArray;\nmyArray = ["Bob", "Fred"];\n\nlet myStr: string = myArray[0]; //当用 number去索引StringArray时会得到string类型的返回值。\n')])])]),r("p",[e._v("略，看不明白，看"),r("a",{attrs:{href:"http://www.tslang.cn/docs/handbook/interfaces.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("官方手册"),r("OutboundLink")],1),e._v("吧")]),e._v(" "),r("h2",{attrs:{id:"类类型"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#类类型"}},[e._v("#")]),e._v(" 类类型")]),e._v(" "),r("p",[e._v("实现接口")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("interface ClockInterface {\n    currentTime: Date;\n    setTime(d: Date);\n}\n\nclass Clock implements ClockInterface {\n    currentTime: Date;\n    setTime(d: Date) {\n        this.currentTime = d;\n    }\n    constructor(h: number, m: number) { }\n}\n")])])])],1)}),[],!1,null,null,null);a.default=t.exports}}]);