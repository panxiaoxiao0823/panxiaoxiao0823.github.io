(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{971:function(n,e,a){"use strict";a.r(e);var t=a(23),r=Object(t.a)({},(function(){var n=this,e=n.$createElement,a=n._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[a("h1",{attrs:{id:"进阶"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#进阶"}},[n._v("#")]),n._v(" 进阶")]),n._v(" "),a("ClientOnly",[a("click")],1),n._v(" "),a("h2",{attrs:{id:"类型别名"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#类型别名"}},[n._v("#")]),n._v(" 类型别名")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("type Name = string;\ntype NameResolver = () => string;\ntype NameOrResolver = Name | NameResolver;\nfunction getName(n: NameOrResolver): Name {\n    if (typeof n === 'string') {\n        return n;\n    } else {\n        return n();\n    }\n}\n")])])]),a("p",[n._v("上例中，我们使用 type 创建类型别名。")]),n._v(" "),a("p",[n._v("类型别名常用于联合类型。")]),n._v(" "),a("h2",{attrs:{id:"字符串字面量类型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#字符串字面量类型"}},[n._v("#")]),n._v(" 字符串字面量类型")]),n._v(" "),a("p",[n._v("字符串字面量类型用来约束取值只能是某几个字符串中的一个")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("type EventNames = 'click' | 'scroll' | 'mousemove';\nfunction handleEvent(ele: Element, event: EventNames) {\n    // do something\n}\n\nhandleEvent(document.getElementById('hello'), 'scroll');  // 没问题\nhandleEvent(document.getElementById('world'), 'dblclick'); // 报错，event 不能为 'dblclick'\n\n// index.ts(7,47): error TS2345: Argument of type '\"dblclick\"' is not assignable to parameter of type 'EventNames'.\n")])])]),a("p",[n._v("上例中，我们使用 type 定了一个字符串字面量类型 EventNames，它只能取三种字符串中的一种。")]),n._v(" "),a("p",[n._v("注意，类型别名与字符串字面量类型都是使用 type 进行定义。")]),n._v(" "),a("h2",{attrs:{id:"类"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#类"}},[n._v("#")]),n._v(" 类")]),n._v(" "),a("h3",{attrs:{id:"_1-访问修饰符-public-private-protected"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-访问修饰符-public-private-protected"}},[n._v("#")]),n._v(" 1. 访问修饰符  public/private/protected")]),n._v(" "),a("p",[n._v("TypeScript 可以使用三种访问修饰符（Access Modifiers），分别是 public、private 和 protected。")]),n._v(" "),a("ul",[a("li",[n._v("public 修饰的属性或方法是公有的，可以在任何地方被访问到，默认所有的属性和方法都是 public 的")]),n._v(" "),a("li",[n._v("private 修饰的属性或方法是私有的，不能在声明它的类的外部访问")]),n._v(" "),a("li",[n._v("protected 修饰的属性或方法是受保护的，它和 private 类似，区别是它在子类中也是允许被访问的")])]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("class Animal {\n    private name;\n    public constructor(name) {\n        this.name = name;\n    }\n}\n  \nlet a = new Animal('Jack');\nconsole.log(a.name); // error 属性“name”为私有属性，只能在类“Animal”中访问。\na.name = 'Tom'; // error 属性“name”为私有属性，只能在类“Animal”中访问。\n")])])]),a("p",[n._v("需要注意的是，TypeScript 编译之后的代码中，并没有限制 private 属性在外部的可访问性。")]),n._v(" "),a("p",[n._v("上面的例子编译后的代码是：")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("var Animal = (function () {\n  function Animal(name) {\n    this.name = name;\n  }\n  return Animal;\n})();\nvar a = new Animal('Jack');\nconsole.log(a.name);\na.name = 'Tom';\n")])])]),a("h3",{attrs:{id:"_2-使用-private-修饰的属性或方法，在子类中也是不允许访问的："}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-使用-private-修饰的属性或方法，在子类中也是不允许访问的："}},[n._v("#")]),n._v(" 2. 使用 private 修饰的属性或方法，在子类中也是不允许访问的：")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("class Animal {\n  private name;\n  public constructor(name) {\n    this.name = name;\n  }\n}\n\nclass Cat extends Animal {\n  constructor(name) {\n    super(name);\n    console.log(this.name); // error 属性“name”为私有属性，只能在类“Animal”中访问。\n  }\n}\n")])])]),a("h3",{attrs:{id:"_3-而如果是用-protected-修饰，则允许在子类中访问："}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-而如果是用-protected-修饰，则允许在子类中访问："}},[n._v("#")]),n._v(" 3. 而如果是用 protected 修饰，则允许在子类中访问：")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("class Animal {\n  protected name;\n  public constructor(name) {\n    this.name = name;\n  }\n}\n\nclass Cat extends Animal {\n  constructor(name) {\n    super(name);\n    console.log(this.name);\n  }\n}\n")])])]),a("h3",{attrs:{id:"_4-当构造函数修饰为-private-时，该类不允许被继承或者实例化："}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-当构造函数修饰为-private-时，该类不允许被继承或者实例化："}},[n._v("#")]),n._v(" 4. 当构造函数修饰为 private 时，该类不允许被继承或者实例化：")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("class Animal {\n  public name;\n  private constructor(name) {\n    this.name = name;\n  }\n}\nclass Cat extends Animal { //error 无法扩展类“Animal”。类构造函数标记为私有。\n  constructor(name) {\n    super(name);\n  }\n}\n\nlet a = new Animal('Jack');  // error 类“Animal”的构造函数是私有的，仅可在类声明中访问。\n")])])]),a("h3",{attrs:{id:"_5-当构造函数修饰为-protected-时，该类只允许被继承："}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-当构造函数修饰为-protected-时，该类只允许被继承："}},[n._v("#")]),n._v(" 5. 当构造函数修饰为 protected 时，该类只允许被继承：")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("class Animal {\n  public name;\n  protected constructor(name) {\n    this.name = name;\n  }\n}\nclass Cat extends Animal {\n  constructor(name) {\n    super(name);\n  }\n}\n\nlet a = new Animal('Jack'); // error 类“Animal”的构造函数是受保护的，仅可在类声明中访问。\n")])])]),a("h3",{attrs:{id:"_6-参数属性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-参数属性"}},[n._v("#")]),n._v(" 6. 参数属性")]),n._v(" "),a("p",[n._v("修饰符和readonly还可以使用在构造函数参数中，等同于类中定义该属性同时给该属性赋值，使代码更简洁。")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("class Animal {\n  // public name: string;\n  public constructor(public name) {\n    // this.name = name;\n  }\n}\n")])])]),a("h3",{attrs:{id:"_7-readonly"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_7-readonly"}},[n._v("#")]),n._v(" 7. readonly")]),n._v(" "),a("p",[n._v("只读属性关键字，只允许出现在属性声明或索引签名或构造函数中。")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("class Animal {\n    readonly name;\n    public constructor(name, readonly age) {\n        this.name = name;\n        this.age = age;\n    }\n}\n\nlet a = new Animal('Jack', 12);\nconsole.log(a.name); // Jack\na.name = 'Tom'; // error 无法分配到 \"name\" ，因为它是只读属性。\na.age = 18; // error 无法分配到 \"age\" ，因为它是只读属性。\n")])])]),a("p",[n._v("注意如果 readonly 和其他访问修饰符同时存在的话，需要写在其后面。")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("class Animal {\n  // public readonly name;\n  public constructor(public readonly name) {\n    // this.name = name;\n  }\n}\n")])])]),a("h3",{attrs:{id:"_8-抽象类"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_8-抽象类"}},[n._v("#")]),n._v(" 8. 抽象类")]),n._v(" "),a("p",[n._v("abstract 用于定义抽象类和其中的抽象方法。"),a("br"),n._v("\n什么是抽象类？"),a("br"),n._v("\n首先，抽象类是不允许被实例化的：")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("abstract class Animal {\n  public name;\n  public constructor(name) {\n    this.name = name;\n  }\n  public abstract sayHi();\n}\n\nlet a = new Animal('Jack'); //error 无法创建抽象类的实例。\n")])])]),a("p",[n._v("上面的例子中，我们定义了一个抽象类 Animal，并且定义了一个抽象方法 sayHi。在实例化抽象类的时候报错了。"),a("br"),n._v("\n其次，抽象类中的抽象方法必须被子类实现：")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("abstract class Animal {\n  public name;\n  public constructor(name) {\n    this.name = name;\n  }\n  public abstract sayHi();\n}\n\nclass Cat extends Animal {  //error 非抽象类“Cat”不会实现继承自“Animal”类的抽象成员“sayHi”。\n  public eat() {\n    console.log(`${this.name} is eating.`);\n  }\n}\n\nlet cat = new Cat('Tom');\n")])])]),a("p",[n._v("上面的例子中，我们定义了一个类 Cat 继承了抽象类 Animal，但是没有实现抽象方法 sayHi，所以编译报错了。"),a("br"),n._v("\n下面是一个正确使用抽象类的例子：")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("abstract class Animal {\n  public name;\n  public constructor(name) {\n    this.name = name;\n  }\n  public abstract sayHi();\n}\n\nclass Cat extends Animal {\n  public sayHi() {\n    console.log(`Meow, My name is ${this.name}`);\n  }\n}\n\nlet cat = new Cat('Tom');\n")])])]),a("p",[n._v("上面的例子中，我们实现了抽象方法 sayHi，编译通过了。")]),n._v(" "),a("p",[n._v("需要注意的是，即使是抽象方法，TypeScript 的编译结果中，仍然会存在这个类，上面的代码的编译结果是：")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("var __extends =\n  (this && this.__extends) ||\n  function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : ((__.prototype = b.prototype), new __());\n  };\nvar Animal = (function () {\n  function Animal(name) {\n    this.name = name;\n  }\n  return Animal;\n})();\nvar Cat = (function (_super) {\n  __extends(Cat, _super);\n  function Cat() {\n    _super.apply(this, arguments);\n  }\n  Cat.prototype.sayHi = function () {\n    console.log('Meow, My name is ' + this.name);\n  };\n  return Cat;\n})(Animal);\nvar cat = new Cat('Tom');\n")])])]),a("h3",{attrs:{id:"_9-类的类型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_9-类的类型"}},[n._v("#")]),n._v(" 9. 类的类型")]),n._v(" "),a("p",[n._v("给类加上 TypeScript 的类型很简单，与接口类似：")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("class Animal {\n  name: string;\n  constructor(name: string) {\n    this.name = name;\n  }\n  sayHi(): string {\n    return `My name is ${this.name}`;\n  }\n}\n\nlet a: Animal = new Animal('Jack');\nconsole.log(a.sayHi()); // My name is Jack\n")])])]),a("h2",{attrs:{id:"类与接口"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#类与接口"}},[n._v("#")]),n._v(" 类与接口")]),n._v(" "),a("h3",{attrs:{id:"_1-类实现接口"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-类实现接口"}},[n._v("#")]),n._v(" 1. 类实现接口")]),n._v(" "),a("p",[n._v("实现（implements）是面向对象中的一个重要概念。一般来讲，一个类只能继承自另一个类，有时候不同类之间可以有一些共有的特性，这时候就可以把特性提取成接口（interfaces），用 implements 关键字来实现。这个特性大大提高了面向对象的灵活性。")]),n._v(" "),a("p",[n._v("举例来说，门是一个类，防盗门是门的子类。如果防盗门有一个报警器的功能，我们可以简单的给防盗门添加一个报警方法。这时候如果有另一个类，车，也有报警器的功能，就可以考虑把报警器提取出来，作为一个接口，防盗门和车都去实现它：")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("interface Alarm {\n    alert(): void;\n}\n\nclass Door {\n}\n\nclass SecurityDoor extends Door implements Alarm {\n    alert() {\n        console.log('SecurityDoor alert');\n    }\n}\n\nclass Car implements Alarm {\n    alert() {\n        console.log('Car alert');\n    }\n}\n")])])]),a("p",[n._v("一个类可以实现多个接口：")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("interface Alarm {\n    alert(): void;\n}\n\ninterface Light {\n    lightOn(): void;\n    lightOff(): void;\n}\n\nclass Car implements Alarm, Light {\n    alert() {\n        console.log('Car alert');\n    }\n    lightOn() {\n        console.log('Car light on');\n    }\n    lightOff() {\n        console.log('Car light off');\n    }\n}\n")])])]),a("p",[n._v("上例中，Car 实现了 Alarm 和 Light 接口，既能报警，也能开关车灯。")]),n._v(" "),a("h3",{attrs:{id:"_2-接口继承接口"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-接口继承接口"}},[n._v("#")]),n._v(" 2. 接口继承接口")]),n._v(" "),a("p",[n._v("接口与接口之间可以是继承关系：")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("interface Alarm {\n    alert(): void;\n}\n\ninterface LightableAlarm extends Alarm {\n    lightOn(): void;\n    lightOff(): void;\n}\n")])])]),a("p",[n._v("这很好理解，LightableAlarm 继承了 Alarm，除了拥有 alert 方法之外，还拥有两个新方法 lightOn 和 lightOff。")]),n._v(" "),a("h3",{attrs:{id:"_3-接口继承类"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-接口继承类"}},[n._v("#")]),n._v(" 3. 接口继承类")]),n._v(" "),a("p",[n._v("常见的面向对象语言中，接口是不能继承类的，但是在 TypeScript 中却是可以的：")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("class Point {\n    x: number;\n    y: number;\n    constructor(x: number, y: number) {\n        this.x = x;\n        this.y = y;\n    }\n}\n\ninterface Point3d extends Point {\n    z: number;\n}\n\nlet point3d: Point3d = {x: 1, y: 2, z: 3};\n")])])]),a("p",[n._v("声明 Point 类时创建的 Point 类型只包含其中的实例属性和实例方法【即不包括构造函数、静态属性或静态方法】：")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("class Point {\n    /** 静态属性，坐标系原点 */\n    static origin = new Point(0, 0);\n    /** 静态方法，计算与原点距离 */\n    static distanceToOrigin(p: Point) {\n        return Math.sqrt(p.x * p.x + p.y * p.y);\n    }\n    /** 实例属性，x 轴的值 */\n    x: number;\n    /** 实例属性，y 轴的值 */\n    y: number;\n    /** 构造函数 */\n    constructor(x: number, y: number) {\n        this.x = x;\n        this.y = y;\n    }\n    /** 实例方法，打印此点 */\n    printPoint() {\n        console.log(this.x, this.y);\n    }\n}\n\ninterface PointInstanceType {\n    x: number;\n    y: number;\n    printPoint(): void;\n}\n\nlet p1: Point;\nlet p2: PointInstanceType;\n")])])]),a("p",[n._v("上例中最后的类型 Point 和类型 PointInstanceType 是等价的。")]),n._v(" "),a("p",[n._v("同样的，在接口继承类的时候，也只会继承它的实例属性和实例方法。")]),n._v(" "),a("h2",{attrs:{id:"泛型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#泛型"}},[n._v("#")]),n._v(" 泛型")]),n._v(" "),a("p",[n._v("泛型（Generics）是指在定义函数、接口或类的时候，不预先指定具体的类型，而在使用的时候再指定类型的一种特性。")]),n._v(" "),a("h3",{attrs:{id:"_1-简单的例子"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-简单的例子"}},[n._v("#")]),n._v(" 1. 简单的例子")]),n._v(" "),a("p",[n._v("首先，我们来实现一个函数 createArray，它可以创建一个指定长度的数组，同时将每一项都填充一个默认值：")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("function createArray(length: number, value: any): Array<any> {\n    let result = [];\n    for (let i = 0; i < length; i++) {\n        result[i] = value;\n    }\n    return result;\n}\n\ncreateArray(3, 'x'); // ['x', 'x', 'x']\n")])])]),a("p",[n._v("上例中，我们使用了之前提到过的数组泛型来定义返回值的类型。"),a("br"),n._v("\n这段代码编译不会报错，但是一个显而易见的缺陷是，它并没有准确的定义返回值的类型：\n"),a("code",[n._v("Array<any>")]),n._v("允许数组的每一项都为任意类型。但是我们预期的是，数组中每一项都应该是输入的 value 的类型。\n这时候，泛型就派上用场了：")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("function createArray<T>(length: number, value: T): Array<T> {\n    let result: T[] = [];\n    for (let i = 0; i < length; i++) {\n        result[i] = value;\n    }\n    return result;\n}\n\ncreateArray<string>(3, 'x'); // ['x', 'x', 'x']\n")])])]),a("p",[n._v("上例中，我们在函数名后添加了 "),a("code",[n._v("<T>")]),n._v("，其中 T 用来指代任意输入的类型，在后面的输入 "),a("code",[n._v("value: T")]),n._v(" 和输出 "),a("code",[n._v("Array<T>")]),n._v(" 中即可使用了。"),a("br"),n._v("\n接着在调用的时候，可以指定它具体的类型为 string。当然，也可以不手动指定，而让类型推论自动推算出来：")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("function createArray<T>(length: number, value: T): Array<T> {\n    let result: T[] = [];\n    for (let i = 0; i < length; i++) {\n        result[i] = value;\n    }\n    return result;\n}\n\ncreateArray(3, 'x'); // ['x', 'x', 'x']\n")])])]),a("h3",{attrs:{id:"_2-多个类型参数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-多个类型参数"}},[n._v("#")]),n._v(" 2. 多个类型参数")]),n._v(" "),a("p",[n._v("定义泛型的时候，可以一次定义多个类型参数：")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("function swap<T, U>(tuple: [T, U]): [U, T] {\n    return [tuple[1], tuple[0]];\n}\n\nswap([7, 'seven']); // ['seven', 7]\n")])])]),a("p",[n._v("上例中，我们定义了一个 swap 函数，用来交换输入的元组。")]),n._v(" "),a("h3",{attrs:{id:"_3-泛型约束"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-泛型约束"}},[n._v("#")]),n._v(" 3. 泛型约束")]),n._v(" "),a("p",[n._v("在函数内部使用泛型变量的时候，由于事先不知道它是哪种类型，所以不能随意的操作它的属性或方法：")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("function loggingIdentity<T>(arg: T): T {\n    console.log(arg.length);\n    return arg;\n}\n\n// index.ts(2,19): error TS2339: Property 'length' does not exist on type 'T'.\n")])])]),a("p",[n._v("上例中，泛型 T 不一定包含属性 length，所以编译的时候报错了。"),a("br"),n._v("\n这时，我们可以对泛型进行约束，只允许这个函数传入那些包含 length 属性的变量。这就是泛型约束：")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("interface Lengthwise {\n    length: number;\n}\n\nfunction loggingIdentity<T extends Lengthwise>(arg: T): T {\n    console.log(arg.length);\n    return arg;\n}\n")])])]),a("p",[n._v("上例中，我们使用了 extends 约束了泛型 T 必须符合接口 Lengthwise 的形状，也就是必须包含 length 属性。"),a("br"),n._v("\n此时如果调用 loggingIdentity 的时候，传入的 arg 不包含 length，那么在编译阶段就会报错了：")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("interface Lengthwise {\n    length: number;\n}\n\nfunction loggingIdentity<T extends Lengthwise>(arg: T): T {\n    console.log(arg.length);\n    return arg;\n}\n\nloggingIdentity(7);\n\n// index.ts(10,17): error TS2345: Argument of type '7' is not assignable to parameter of type 'Lengthwise'.\n")])])]),a("p",[n._v("多个类型参数之间也可以互相约束：")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("function copyFields<T extends U, U>(target: T, source: U): T {\n    for (let id in source) {\n        target[id] = (<T>source)[id];\n    }\n    return target;\n}\n\nlet x = { a: 1, b: 2, c: 3, d: 4 };\n\ncopyFields(x, { b: 10, d: 20 });\n")])])]),a("p",[n._v("上例中，我们使用了两个类型参数，其中要求 T 继承 U，这样就保证了 U 上不会出现 T 中不存在的字段。")]),n._v(" "),a("h3",{attrs:{id:"_4-泛型接口"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-泛型接口"}},[n._v("#")]),n._v(" 4. 泛型接口")]),n._v(" "),a("p",[n._v("之前学习过，可以使用接口的方式来定义一个函数需要符合的形状：")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("interface SearchFunc {\n  (source: string, subString: string): boolean;\n}\n\nlet mySearch: SearchFunc;\nmySearch = function(source: string, subString: string) {\n    return source.search(subString) !== -1;\n}\n")])])]),a("p",[n._v("当然也可以使用含有泛型的接口来定义函数的形状：")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("interface CreateArrayFunc {\n    <T>(length: number, value: T): Array<T>;\n}\n\nlet createArray: CreateArrayFunc;\ncreateArray = function<T>(length: number, value: T): Array<T> {\n    let result: T[] = [];\n    for (let i = 0; i < length; i++) {\n        result[i] = value;\n    }\n    return result;\n}\n\ncreateArray(3, 'x'); // ['x', 'x', 'x']\n")])])]),a("p",[n._v("进一步，我们可以把泛型参数提前到接口名上：")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("interface CreateArrayFunc<T> {\n    (length: number, value: T): Array<T>;\n}\n\nlet createArray: CreateArrayFunc<any>;\ncreateArray = function<T>(length: number, value: T): Array<T> {\n    let result: T[] = [];\n    for (let i = 0; i < length; i++) {\n        result[i] = value;\n    }\n    return result;\n}\n\ncreateArray(3, 'x'); // ['x', 'x', 'x']\n")])])]),a("p",[n._v("注意，此时在使用泛型接口的时候，需要定义泛型的类型。")]),n._v(" "),a("h3",{attrs:{id:"_5-泛型类"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-泛型类"}},[n._v("#")]),n._v(" 5. 泛型类")]),n._v(" "),a("p",[n._v("与泛型接口类似，泛型也可以用于类的类型定义中：")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("class GenericNumber<T> {\n    zeroValue: T;\n    add: (x: T, y: T) => T;\n}\n\nlet myGenericNumber = new GenericNumber<number>();\nmyGenericNumber.zeroValue = 0;\nmyGenericNumber.add = function(x, y) { return x + y; };\n")])])]),a("h3",{attrs:{id:"_6-泛型参数的默认类型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-泛型参数的默认类型"}},[n._v("#")]),n._v(" 6. 泛型参数的默认类型")]),n._v(" "),a("p",[n._v("在 TypeScript 2.3 以后，我们可以为泛型中的类型参数指定默认类型。当使用泛型时没有在代码中直接指定类型参数，从实际值参数中也无法推测出时，这个默认类型就会起作用。")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("function createArray<T = string>(length: number, value: T): Array<T> {\n    let result: T[] = [];\n    for (let i = 0; i < length; i++) {\n        result[i] = value;\n    }\n    return result;\n}\n")])])]),a("h2",{attrs:{id:"声明合并"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#声明合并"}},[n._v("#")]),n._v(" 声明合并")]),n._v(" "),a("p",[n._v("如果定义了两个相同名字的函数、接口或类，那么它们会合并成一个类型：")]),n._v(" "),a("h3",{attrs:{id:"_1-函数的合并-【使用重载】"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-函数的合并-【使用重载】"}},[n._v("#")]),n._v(" 1. 函数的合并 【使用重载】")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("function reverse(x: number): number;\nfunction reverse(x: string): string;\nfunction reverse(x: number | string): number | string {\n    if (typeof x === 'number') {\n        return Number(x.toString().split('').reverse().join(''));\n    } else if (typeof x === 'string') {\n        return x.split('').reverse().join('');\n    }\n}\n")])])]),a("h3",{attrs:{id:"_2-接口的合并"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-接口的合并"}},[n._v("#")]),n._v(" 2. 接口的合并")]),n._v(" "),a("p",[n._v("注意，合并的属性的类型必须是唯一的：")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("interface Alarm {\n    price: number;\n    alert(s: string): string;\n}\ninterface Alarm {\n    price: number;  // 虽然重复了，但是类型都是 `number`，所以不会报错；如果改成price:string则会报错\n    weight: number;\n    alert(s: string, n: number): string;\n}\n\nlet a: Alarm = {\n    weight: 2,\n    price: 10,\n    alert(a: string, b: number): string { // error 不能将类型“(a: string, b: number) => string”分配给类型“{ (s: string): string; (s: string, n: number): string; }”\n        return '2'\n    }\n}\n\na.alert('hello', 11)\n")])])]),a("div",{staticClass:"custom-block warning"},[a("p",{staticClass:"custom-block-title"},[n._v("WARNING")]),n._v(" "),a("p",[n._v("上面代码alert方法的合并，会报错，不明白为什么")])]),n._v(" "),a("h3",{attrs:{id:"_3-类的合并"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-类的合并"}},[n._v("#")]),n._v(" 3. 类的合并")]),n._v(" "),a("p",[n._v("类的合并与接口的合并规则一致。")])],1)}),[],!1,null,null,null);e.default=r.exports}}]);